 - Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies
 - Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression
 - Diagnostics.Cannot_find_name_0

```js
class C {
    q = #unbound
    m() {
        #p++
        q++
        this.#q
        if (#po in this) {

        }
        const o = { a: 1, a: 2 }
        return o.a
    }
    #m() {
         this.#m = () => {}
    }
}
#unrelated
```

These 3 errors need improvement, but at least the first two should behave the same in JS as TS

 - Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable

```js
class C {
    #m() {
         this.#m = () => {}
    }
}
```

 - Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies
`junk.#m` (you get a better error if C is defined and even better if C.#m is defined)

 - Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses

```js
var x = 1 || 2 ?? 2
var x = 2 ?? 3 || 4
var x = -2 ** 3
```

 - Diagnostics.For_await_loops_cannot_be_used_inside_a_class_static_block

```js
class C {
    static {
        for await (const x of [1,2,3]) {
            console.log(x)
        }
    }
}
```

 - Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement

```js
var b = true
switch (b) {
    case false:
        console.log('no')
    default:
        console.log('yes')
    default:
        console.log('wat')
}
```

 - Diagnostics.Duplicate_label_0

```js
label: for (const x in [1,2,3]) {
    label: for (const y in [1,2,3]) {
        break label;
    }
}
```

 - Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause

```js
try {
    throw 2
}
catch (e) {
    const e = 1
    console.log(e)
}
```

 - Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator

```js
declare var deco: any
@deco
class C {
    static #p = 1
}
```

But this doesn't run on any JS runtime today so it probably shouldn't apply

 - Diagnostics.A_class_member_cannot_have_the_0_keyword

```js
 class C {
    const x = 1
    const y() {
        return 12
    }
}
```

 - Diagnostics._0_modifier_already_seen

```js
class C {
    static static x = 1
}
```

 - Diagnostics._0_modifier_must_precede_1_modifier

```js
class C {
    static async x (){ }
}
```

 - Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element

```js
export static var x = 1
```

 - Diagnostics._0_modifier_cannot_appear_on_a_parameter

```js
function f(static x = 1) { return x }
```

 - Diagnostics._0_modifier_already_seen

```js
export export var x = 1
```

 - Diagnostics._0_modifier_must_precede_1_modifier

```js
async export function f(x = 1) { return x }
```

 - Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind

```js
class C {
    export p = 1
    export m() {
    }
}
```

Note that there's an existing, bogus error in JS which is supposed to be issued on
  exports from namespaces, which are not in JS of course.

 - Diagnostics._0_modifier_cannot_appear_on_a_parameter

```js
function f(export x = 1) { return x }
```

 - Diagnostics._0_modifier_must_precede_1_modifier

```js
default export 13;
```

 - Diagnostics._0_modifier_already_seen

```js
async async function f() {
    return 1
}
```

 - Diagnostics._0_modifier_cannot_appear_on_a_parameter

```js
function f(async x = 1) { return x }
```

 - Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration

```js
class C {
    static constructor() { }
}
```

 - Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration

```js
class C {
    async constructor() { }
}
```

 - Diagnostics._0_modifier_cannot_be_used_here

```js
async class C {
    async x = 1
}
async const y = 2
async import './other'
async export { C }
```

 - Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list

```js
function f (...x, y) {
}
```

 - Diagnostics.A_rest_parameter_cannot_have_an_initializer

```js
function f (...x = [1,2,3]) {
}
```

 - Diagnostics.Line_terminator_not_permitted_before_arrow

```js
const arr = x
  => x + 1
  ```
  
 - Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain

```js
var a = [1,2]
a?.`length`;
```

 - Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name

```js
const o = {
    [console.log('oh no'),2]: 'hi'
}
```


 - InvalidQuestionMark

```js
const o = {
    x?: 12
}
```

 But: this already errors with a JS-specific error, so maybe the first should too.

```js
const o = {
    m?() { return 12 }
}
```

 - InvalidExclamationToken

```js
var x = 1
const o = {
    x!
}
const o = {
    m!() { return 12 }
}
```

 - Diagnostics.A_rest_element_cannot_contain_a_binding_pattern

```js
const o = {
    x: 1, y: 2
}
let x; let y
;({ ...[] } = o)
```

 - Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern

```js
const o = { x = 1 }
```

 - Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies

```js
const o = { #x: 1 }
```

 - Diagnostics._0_modifier_cannot_be_used_here

```js
const o = { export x: 1 }
```

 - Diagnostics.Duplicate_identifier_0

TODO: Duplicated with An object literal cannot have multiple properties with the same name in strict mode.

```js
const o = { 
    x: 1,
    x() { }
```
    
 - Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name
 - Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression
 - Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names
 - Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array
  -- TODO Come back here and figure out what JSX errors are good --

 - Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async

```js
let async
export const l = [1,2,3]
for (async of l) {
    console.log(x)
}
```

 - Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer

```js
for (const x = 1 in [1,2,3]) {
    console.log(x)
}
```

 - Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer;

```js
for (const x = 1 of [1,2,3]) {
    console.log(x)
}
```

 - Diagnostics._0_Expected

```js
class C {
    get x();
}
```

 - Diagnostics.A_get_accessor_cannot_have_parameters

```js
class C {
    get x(n) { return 1 }
}
```

 - Diagnostics.A_set_accessor_must_have_exactly_one_parameter

```js
class C {
    set x() { }
    set y(a, b) { }
}
```

 - Diagnostics.A_set_accessor_cannot_have_rest_parameter

```js
class C {
    set x(...n) { }
}
```

 - Diagnostics.Jump_target_cannot_cross_function_boundary

```js
function outer() {
    outer: for(;;) {
        function test() {
            break outer
        }
        test()
    }
}
outer()
```

 - Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement

```js
function outer(x) {
    outer: switch (x) {
        case 1:
            continue outer
    }
}
outer(1)
```

 - Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement

```js
function outer(x) {
    break outer
}
```

 - Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;

```js
function outer(x) {
    continue outer
}
outer(1)
```

 - Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement

```js
function outer(x) {
    break
}
```

 - Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;

```js
function outer(x) {
    continue
}
```

 - Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern

```js
const o = { e: 1, m: 1, name: "knee-deep" }
const { ...rest, e: a, m: n } = o
a + n
```

 - Diagnostics.A_rest_element_cannot_have_a_property_name

```js
const o = { e: 1, m: 1, name: "knee-deep" }
const { e: a, m: n, ...est: x } = o
a + n
```

 - Diagnostics.A_destructuring_declaration_must_have_an_initializer

```js
const { e: a, m: n }
```

 - Diagnostics.const_declarations_must_be_initialized

```js
const a
```

 - Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations

```js
let let = 12
```

 - Diagnostics.let_declarations_can_only_be_declared_inside_a_block

```js
if (true)
  let c3 = 0
```
  
 - Diagnostics.const_declarations_can_only_be_declared_inside_a_block

```js
if (true)
  const c3 = 0
```
  
 - Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2

```js
export let x = import.metal
```

 - Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2

```js
function foo() { new.targe }
```

 - Diagnostics.Classes_may_not_have_a_field_named_constructor

```js
class C {
    "constructor" = 1
}
```

 - Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments

```js
const x = import()
const y = import('1', '2', '3')
```

 - Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element

```js
const x = import(...[])
```

