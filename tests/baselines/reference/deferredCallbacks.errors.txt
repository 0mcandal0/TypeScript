deferredCallbacks.ts(119,22): error TS2869: A 'deferred' parameter must have a type that permits functions.
deferredCallbacks.ts(120,22): error TS2869: A 'deferred' parameter must have a type that permits functions.
deferredCallbacks.ts(121,22): error TS2869: A 'deferred' parameter must have a type that permits functions.
deferredCallbacks.ts(128,13): error TS2869: A 'deferred' parameter must have a type that permits functions.
deferredCallbacks.ts(129,13): error TS2869: A 'deferred' parameter must have a type that permits functions.
deferredCallbacks.ts(130,13): error TS2869: A 'deferred' parameter must have a type that permits functions.
deferredCallbacks.ts(131,14): error TS1070: 'deferred' modifier cannot appear on a type member.


==== deferredCallbacks.ts (7 errors) ====
    declare function immediate(cb: () => void): void;
    declare function deferred1(deferred cb: () => void): void;
    declare function deferred2(/** @deferred */ cb: () => void): void;
    declare function deferred3(/** @deferred */ deferred cb: () => void): void;
    
    function f01() {
        let x: string | number = "OK";
        immediate(() => {
            x = 42;
        });
        x;  // string | number
    }
    
    function f02() {
        let x: string | number = "OK";
        deferred1(() => {
            x = 42;
        });
        x;  // string
    }
    
    function f03() {
        let x: string | number = "OK";
        deferred2(() => {
            x = 42;
        });
        x;  // string
    }
    
    function f04() {
        let x: string | number = "OK";
        deferred3(() => {
            x = 42;
        });
        x;  // string
    }
    
    // Parameter is considered deferred if one or more overloads defer that parameter
    
    declare function overloaded<T>(cb: (x: T) => T): void;
    declare function overloaded<T>(cb: (x: T, y: T) => T): void;
    declare function overloaded(deferred cb: (...args: any) => any): void;
    
    function f05() {
        let x: string | number = "OK";
        overloaded(() => {
            x = 42;
        });
        x.length;
    }
    
    // deferred is permitted on a rest parameter
    
    declare function invokeImmediate(...args: ((...args: any) => any)[]): void;
    declare function invokeDeferred(deferred ...args: ((...args: any) => any)[]): void;
    
    function f06() {
        let a = [];
        a.push("abc");
        a;  // string[]
        invokeImmediate(
            () => {
                a;  // string[]
                a.push(42);
                a;  // (string | number)[]
            },
            () => {
                a;  // string[]
                a.push(true);
                a;  // (string | boolean)[]
            }
        );
        a;  // (string | number | boolean)[]
    }
    
    function f07() {
        let a = [];
        a.push("abc");
        a;  // string[]
        invokeDeferred(
            () => {
                a;  // string[]
                a.push(42);
                a;  // (string | number)[]
            },
            () => {
                a;  // string[]
                a.push(true);
                a;  // (string | boolean)[]
            }
        );
        a;  // string[]
    }
    
    // deferred modifier must precede public/private/protected/readonly
    
    class CC {
        constructor(deferred public readonly x: () => void) {}
    }
    
    // deferred requires parameter to have type that permits functions
    
    declare function f10(deferred f: () => void): void;
    declare function f11(deferred f: Function): void;
    declare function f12(deferred f: any): void;
    declare function f13(deferred f: object): void;
    declare function f14(deferred f: {}): void;
    declare function f15(deferred f: unknown): void;
    declare function f16<T extends Function>(deferred f: T): void;
    declare function f17<T extends (...args: any) => any>(deferred f: T): void;
    declare function f18<T extends string | (() => void)>(deferred f: T): void;
    
    declare function f20(deferred ...funcs: Function[]): void;
    declare function f21<T extends ((...args: any) => any)[]>(deferred ...funcs: T): void;
    declare function f22<T extends (string | (() => void))[]>(deferred ...funcs: T): void;
    declare function f23<T extends string[] | (() => void)[]>(deferred ...funcs: T): void;
    declare function f24<T extends (() => void)[]>(deferred ...funcs: T | string[]): void;
    
    declare function f30(deferred f: { foo(): void }): void;
                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2869: A 'deferred' parameter must have a type that permits functions.
    declare function f31(deferred f: number): void;
                         ~~~~~~~~~~~~~~~~~~
!!! error TS2869: A 'deferred' parameter must have a type that permits functions.
    declare function f32(deferred ...funcs: number[]): void;
                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2869: A 'deferred' parameter must have a type that permits functions.
    
    type T10 = (deferred f: () => void) => void;
    type T11 = (deferred f: { (): void }) => void;
    type T12 = (deferred f: Function) => void;
    type T13 = (deferred f: any) => void;
    
    type T20 = (deferred f: { foo(): void }) => void;
                ~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2869: A 'deferred' parameter must have a type that permits functions.
    type T21 = (deferred f: number) => void;
                ~~~~~~~~~~~~~~~~~~
!!! error TS2869: A 'deferred' parameter must have a type that permits functions.
    type T22 = (deferred ...funcs: number[]) => void;
                ~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2869: A 'deferred' parameter must have a type that permits functions.
    type T23 = { deferred x: () => void };
                 ~~~~~~~~
!!! error TS1070: 'deferred' modifier cannot appear on a type member.
    
    // deferred modifier is not captured in argument list tuples
    
    declare function doStuff(deferred f: () => void): void;
    
    declare function recreate<A extends unknown[], R>(f: (...args: A) => R): (...args: A) => R;
    declare function recreateDeferred1<A extends unknown[], R>(f: (deferred ...args: A) => R): (...args: A) => R;
    declare function recreateDeferred2<A extends unknown[], R>(f: (...args: A) => R): (deferred ...args: A) => R;
    
    function ff1() {
        let x: string | number;
        x = 123;
        doStuff(() => {
            x = "hi";
        });
        x;  // number
    }
    
    function ff2() {
        let y: string | number;
        y = 123;
        recreate(doStuff)(() => {
            y = "hi";
        });
        y;  // string | number
    }
    
    function ff3() {
        let z: string | number;
        z = 123;
        recreateDeferred1(doStuff)(() => {
            z = "hi";
        });
        z;  // string | number
    }
    
    function ff4() {
        let z: string | number;
        z = 123;
        recreateDeferred2(doStuff)(() => {
            z = "hi";
        });
        z;  // number
    }
    
    // https://github.com/microsoft/TypeScript/issues/11498
    
    declare function mystery(cb: () => void): void;
    
    function fx1() {
        let x: string | number = "OK";
        x;  // string
        mystery(() => {
            x = 10;
        });
        x;  // string | number
        if (x === 10) {}
    }
    
    // https://github.com/microsoft/TypeScript/issues/15380
    
    class Foo {
      public bar: string = "";
    }
    
    function fx2() {
      let foo: Foo | null = null;
      [1].forEach((item) => {
          foo = new Foo();
      });
      if (foo) {
          foo.bar;
      }
    }
    
    // https://github.com/microsoft/TypeScript/issues/57880
    
    const call = (f: () => void) => f();
    
    const fx3 = () => {
        let a: undefined | number = undefined;
        call(() => { a = 1; });
        if (a !== undefined) {
            a.toString();
        }
    };
    
    // https://github.com/microsoft/TypeScript/issues/58291
    
    async function execute(onError: (_err: Error | undefined) => void) {
        onError(new Error("a"));
    }
    
    async function run() {
        let result: boolean = true;
        await execute(() => {
            result = false;
        });
        if (result === false) {
            console.log("error");
        }
        return result;
    }
    