//// [tests/cases/compiler/enforceReadonly1.ts] ////

=== enforceReadonly1.ts ===
// A read-only property is not assignable to a mutable property

function f1(mp: { x: string }, rp: { readonly x: string }, mx: { [x: string]: string }, rx: { readonly [x: string]: string }) {
>f1 : Symbol(f1, Decl(enforceReadonly1.ts, 0, 0))
>mp : Symbol(mp, Decl(enforceReadonly1.ts, 2, 12))
>x : Symbol(x, Decl(enforceReadonly1.ts, 2, 17))
>rp : Symbol(rp, Decl(enforceReadonly1.ts, 2, 30))
>x : Symbol(x, Decl(enforceReadonly1.ts, 2, 36))
>mx : Symbol(mx, Decl(enforceReadonly1.ts, 2, 58))
>x : Symbol(x, Decl(enforceReadonly1.ts, 2, 66))
>rx : Symbol(rx, Decl(enforceReadonly1.ts, 2, 87))
>x : Symbol(x, Decl(enforceReadonly1.ts, 2, 104))

    mp = rp;  // Error
>mp : Symbol(mp, Decl(enforceReadonly1.ts, 2, 12))
>rp : Symbol(rp, Decl(enforceReadonly1.ts, 2, 30))

    rp = mp;
>rp : Symbol(rp, Decl(enforceReadonly1.ts, 2, 30))
>mp : Symbol(mp, Decl(enforceReadonly1.ts, 2, 12))

    mx = mp;
>mx : Symbol(mx, Decl(enforceReadonly1.ts, 2, 58))
>mp : Symbol(mp, Decl(enforceReadonly1.ts, 2, 12))

    mx = rp;
>mx : Symbol(mx, Decl(enforceReadonly1.ts, 2, 58))
>rp : Symbol(rp, Decl(enforceReadonly1.ts, 2, 30))

    mx = rx;  // Error
>mx : Symbol(mx, Decl(enforceReadonly1.ts, 2, 58))
>rx : Symbol(rx, Decl(enforceReadonly1.ts, 2, 87))

    rx = mp;
>rx : Symbol(rx, Decl(enforceReadonly1.ts, 2, 87))
>mp : Symbol(mp, Decl(enforceReadonly1.ts, 2, 12))

    rx = rp;
>rx : Symbol(rx, Decl(enforceReadonly1.ts, 2, 87))
>rp : Symbol(rp, Decl(enforceReadonly1.ts, 2, 30))

    rx = mx;
>rx : Symbol(rx, Decl(enforceReadonly1.ts, 2, 87))
>mx : Symbol(mx, Decl(enforceReadonly1.ts, 2, 58))
}

type Mutable<T> = { -readonly [P in keyof T]: T[P] };
>Mutable : Symbol(Mutable, Decl(enforceReadonly1.ts, 11, 1))
>T : Symbol(T, Decl(enforceReadonly1.ts, 13, 13))
>P : Symbol(P, Decl(enforceReadonly1.ts, 13, 31))
>T : Symbol(T, Decl(enforceReadonly1.ts, 13, 13))
>T : Symbol(T, Decl(enforceReadonly1.ts, 13, 13))
>P : Symbol(P, Decl(enforceReadonly1.ts, 13, 31))

function f2<T>(mt: Mutable<T>, tt: T, rt: Readonly<T>) {
>f2 : Symbol(f2, Decl(enforceReadonly1.ts, 13, 53))
>T : Symbol(T, Decl(enforceReadonly1.ts, 15, 12))
>mt : Symbol(mt, Decl(enforceReadonly1.ts, 15, 15))
>Mutable : Symbol(Mutable, Decl(enforceReadonly1.ts, 11, 1))
>T : Symbol(T, Decl(enforceReadonly1.ts, 15, 12))
>tt : Symbol(tt, Decl(enforceReadonly1.ts, 15, 30))
>T : Symbol(T, Decl(enforceReadonly1.ts, 15, 12))
>rt : Symbol(rt, Decl(enforceReadonly1.ts, 15, 37))
>Readonly : Symbol(Readonly, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(enforceReadonly1.ts, 15, 12))

    mt = tt;  // Error
>mt : Symbol(mt, Decl(enforceReadonly1.ts, 15, 15))
>tt : Symbol(tt, Decl(enforceReadonly1.ts, 15, 30))

    mt = rt;  // Error
>mt : Symbol(mt, Decl(enforceReadonly1.ts, 15, 15))
>rt : Symbol(rt, Decl(enforceReadonly1.ts, 15, 37))

    tt = mt;
>tt : Symbol(tt, Decl(enforceReadonly1.ts, 15, 30))
>mt : Symbol(mt, Decl(enforceReadonly1.ts, 15, 15))

    tt = rt;  // Error
>tt : Symbol(tt, Decl(enforceReadonly1.ts, 15, 30))
>rt : Symbol(rt, Decl(enforceReadonly1.ts, 15, 37))

    rt = mt;
>rt : Symbol(rt, Decl(enforceReadonly1.ts, 15, 37))
>mt : Symbol(mt, Decl(enforceReadonly1.ts, 15, 15))

    rt = tt;
>rt : Symbol(rt, Decl(enforceReadonly1.ts, 15, 37))
>tt : Symbol(tt, Decl(enforceReadonly1.ts, 15, 30))
}

// A read-only property is assignable to a property declared as a method

function f3(m: { foo(): void }, p: { foo: () => void }, r: { readonly foo: () => void }) {
>f3 : Symbol(f3, Decl(enforceReadonly1.ts, 22, 1))
>m : Symbol(m, Decl(enforceReadonly1.ts, 26, 12))
>foo : Symbol(foo, Decl(enforceReadonly1.ts, 26, 16))
>p : Symbol(p, Decl(enforceReadonly1.ts, 26, 31))
>foo : Symbol(foo, Decl(enforceReadonly1.ts, 26, 36))
>r : Symbol(r, Decl(enforceReadonly1.ts, 26, 55))
>foo : Symbol(foo, Decl(enforceReadonly1.ts, 26, 60))

    m = r;
>m : Symbol(m, Decl(enforceReadonly1.ts, 26, 12))
>r : Symbol(r, Decl(enforceReadonly1.ts, 26, 55))

    p = r;  // Error
>p : Symbol(p, Decl(enforceReadonly1.ts, 26, 31))
>r : Symbol(r, Decl(enforceReadonly1.ts, 26, 55))
}

type Paths = string[] & { __brand__: "Paths" };
>Paths : Symbol(Paths, Decl(enforceReadonly1.ts, 29, 1))
>__brand__ : Symbol(__brand__, Decl(enforceReadonly1.ts, 31, 25))

function f4(rp: Readonly<Paths>, rs: Readonly<string[]>) {
>f4 : Symbol(f4, Decl(enforceReadonly1.ts, 31, 47))
>rp : Symbol(rp, Decl(enforceReadonly1.ts, 33, 12))
>Readonly : Symbol(Readonly, Decl(lib.es5.d.ts, --, --))
>Paths : Symbol(Paths, Decl(enforceReadonly1.ts, 29, 1))
>rs : Symbol(rs, Decl(enforceReadonly1.ts, 33, 32))
>Readonly : Symbol(Readonly, Decl(lib.es5.d.ts, --, --))

    rs = rp;
>rs : Symbol(rs, Decl(enforceReadonly1.ts, 33, 32))
>rp : Symbol(rp, Decl(enforceReadonly1.ts, 33, 12))
}

// A derived interface may not change property from mutable to read-only

interface B1 {
>B1 : Symbol(B1, Decl(enforceReadonly1.ts, 35, 1))

    x: number;
>x : Symbol(B1.x, Decl(enforceReadonly1.ts, 39, 14))
}

interface D1 extends B1 {  // Error
>D1 : Symbol(D1, Decl(enforceReadonly1.ts, 41, 1))
>B1 : Symbol(B1, Decl(enforceReadonly1.ts, 35, 1))

    readonly x: number;
>x : Symbol(D1.x, Decl(enforceReadonly1.ts, 43, 25))
}

interface B2 {
>B2 : Symbol(B2, Decl(enforceReadonly1.ts, 45, 1))

    get x(): number;
>x : Symbol(B2.x, Decl(enforceReadonly1.ts, 47, 14), Decl(enforceReadonly1.ts, 48, 20))

    set x(value: number);
>x : Symbol(B2.x, Decl(enforceReadonly1.ts, 47, 14), Decl(enforceReadonly1.ts, 48, 20))
>value : Symbol(value, Decl(enforceReadonly1.ts, 49, 10))
}

interface D2 extends B2 {  // Error
>D2 : Symbol(D2, Decl(enforceReadonly1.ts, 50, 1))
>B2 : Symbol(B2, Decl(enforceReadonly1.ts, 45, 1))

    get x(): number;
>x : Symbol(D2.x, Decl(enforceReadonly1.ts, 52, 25))
}

class B3 {
>B3 : Symbol(B3, Decl(enforceReadonly1.ts, 54, 1))

    x = 0;
>x : Symbol(B3.x, Decl(enforceReadonly1.ts, 56, 10))
}

class D3 extends B3 {  // Error
>D3 : Symbol(D3, Decl(enforceReadonly1.ts, 58, 1))
>B3 : Symbol(B3, Decl(enforceReadonly1.ts, 54, 1))

    readonly x = 1;
>x : Symbol(D3.x, Decl(enforceReadonly1.ts, 60, 21))
}

class B4 {
>B4 : Symbol(B4, Decl(enforceReadonly1.ts, 62, 1))

    foo() {}
>foo : Symbol(B4.foo, Decl(enforceReadonly1.ts, 64, 10))
}

class D4 extends B4 {  // Error
>D4 : Symbol(D4, Decl(enforceReadonly1.ts, 66, 1))
>B4 : Symbol(B4, Decl(enforceReadonly1.ts, 62, 1))

    readonly foo = () => {}
>foo : Symbol(D4.foo, Decl(enforceReadonly1.ts, 68, 21))
}

// A const assertion means "as const as possible" without violating constraints

const x1 = { a: "hello", b: 42 };
>x1 : Symbol(x1, Decl(enforceReadonly1.ts, 74, 5))
>a : Symbol(a, Decl(enforceReadonly1.ts, 74, 12))
>b : Symbol(b, Decl(enforceReadonly1.ts, 74, 24))

const x2 = { a: "hello", b: 42 } as const;
>x2 : Symbol(x2, Decl(enforceReadonly1.ts, 75, 5))
>a : Symbol(a, Decl(enforceReadonly1.ts, 75, 12))
>b : Symbol(b, Decl(enforceReadonly1.ts, 75, 24))
>const : Symbol(const)

const y1: { a: string, b: number } = { a: "hello", b: 42 };
>y1 : Symbol(y1, Decl(enforceReadonly1.ts, 77, 5))
>a : Symbol(a, Decl(enforceReadonly1.ts, 77, 11))
>b : Symbol(b, Decl(enforceReadonly1.ts, 77, 22))
>a : Symbol(a, Decl(enforceReadonly1.ts, 77, 38))
>b : Symbol(b, Decl(enforceReadonly1.ts, 77, 50))

const y2: { a: string, b: number } = { a: "hello", b: 42 } as const;
>y2 : Symbol(y2, Decl(enforceReadonly1.ts, 78, 5))
>a : Symbol(a, Decl(enforceReadonly1.ts, 78, 11))
>b : Symbol(b, Decl(enforceReadonly1.ts, 78, 22))
>a : Symbol(a, Decl(enforceReadonly1.ts, 78, 38))
>b : Symbol(b, Decl(enforceReadonly1.ts, 78, 50))
>const : Symbol(const)

const y3: { a: string, readonly b: number } = { a: "hello", b: 42 };
>y3 : Symbol(y3, Decl(enforceReadonly1.ts, 79, 5))
>a : Symbol(a, Decl(enforceReadonly1.ts, 79, 11))
>b : Symbol(b, Decl(enforceReadonly1.ts, 79, 22))
>a : Symbol(a, Decl(enforceReadonly1.ts, 79, 47))
>b : Symbol(b, Decl(enforceReadonly1.ts, 79, 59))

const y4: Record<string, unknown> = { a: 1, b: 2 } as const;
>y4 : Symbol(y4, Decl(enforceReadonly1.ts, 80, 5))
>Record : Symbol(Record, Decl(lib.es5.d.ts, --, --))
>a : Symbol(a, Decl(enforceReadonly1.ts, 80, 37))
>b : Symbol(b, Decl(enforceReadonly1.ts, 80, 43))
>const : Symbol(const)

declare function f10<T>(obj: T): T;
>f10 : Symbol(f10, Decl(enforceReadonly1.ts, 80, 60))
>T : Symbol(T, Decl(enforceReadonly1.ts, 82, 21))
>obj : Symbol(obj, Decl(enforceReadonly1.ts, 82, 24))
>T : Symbol(T, Decl(enforceReadonly1.ts, 82, 21))
>T : Symbol(T, Decl(enforceReadonly1.ts, 82, 21))

declare function f11<const T>(obj: T): T;
>f11 : Symbol(f11, Decl(enforceReadonly1.ts, 82, 35))
>T : Symbol(T, Decl(enforceReadonly1.ts, 83, 21))
>obj : Symbol(obj, Decl(enforceReadonly1.ts, 83, 30))
>T : Symbol(T, Decl(enforceReadonly1.ts, 83, 21))
>T : Symbol(T, Decl(enforceReadonly1.ts, 83, 21))

declare function f12<const T extends { a: string, b: number }>(obj: T): T;
>f12 : Symbol(f12, Decl(enforceReadonly1.ts, 83, 41))
>T : Symbol(T, Decl(enforceReadonly1.ts, 84, 21))
>a : Symbol(a, Decl(enforceReadonly1.ts, 84, 38))
>b : Symbol(b, Decl(enforceReadonly1.ts, 84, 49))
>obj : Symbol(obj, Decl(enforceReadonly1.ts, 84, 63))
>T : Symbol(T, Decl(enforceReadonly1.ts, 84, 21))
>T : Symbol(T, Decl(enforceReadonly1.ts, 84, 21))

declare function f13<const T extends { a: string, readonly b: number }>(obj: T): T;
>f13 : Symbol(f13, Decl(enforceReadonly1.ts, 84, 74))
>T : Symbol(T, Decl(enforceReadonly1.ts, 85, 21))
>a : Symbol(a, Decl(enforceReadonly1.ts, 85, 38))
>b : Symbol(b, Decl(enforceReadonly1.ts, 85, 49))
>obj : Symbol(obj, Decl(enforceReadonly1.ts, 85, 72))
>T : Symbol(T, Decl(enforceReadonly1.ts, 85, 21))
>T : Symbol(T, Decl(enforceReadonly1.ts, 85, 21))

declare function f14<const T extends Record<string, unknown>>(obj: T): T;
>f14 : Symbol(f14, Decl(enforceReadonly1.ts, 85, 83))
>T : Symbol(T, Decl(enforceReadonly1.ts, 86, 21))
>Record : Symbol(Record, Decl(lib.es5.d.ts, --, --))
>obj : Symbol(obj, Decl(enforceReadonly1.ts, 86, 62))
>T : Symbol(T, Decl(enforceReadonly1.ts, 86, 21))
>T : Symbol(T, Decl(enforceReadonly1.ts, 86, 21))

declare function f15<const T extends Readonly<Record<string, unknown>>>(obj: T): T;
>f15 : Symbol(f15, Decl(enforceReadonly1.ts, 86, 73))
>T : Symbol(T, Decl(enforceReadonly1.ts, 87, 21))
>Readonly : Symbol(Readonly, Decl(lib.es5.d.ts, --, --))
>Record : Symbol(Record, Decl(lib.es5.d.ts, --, --))
>obj : Symbol(obj, Decl(enforceReadonly1.ts, 87, 72))
>T : Symbol(T, Decl(enforceReadonly1.ts, 87, 21))
>T : Symbol(T, Decl(enforceReadonly1.ts, 87, 21))

f10({ a: "hello", b: 42 });  // { a: string; b: number; }
>f10 : Symbol(f10, Decl(enforceReadonly1.ts, 80, 60))
>a : Symbol(a, Decl(enforceReadonly1.ts, 89, 5))
>b : Symbol(b, Decl(enforceReadonly1.ts, 89, 17))

f11({ a: "hello", b: 42 });  // { readonly a: "hello"; readonly b: 42; }
>f11 : Symbol(f11, Decl(enforceReadonly1.ts, 82, 35))
>a : Symbol(a, Decl(enforceReadonly1.ts, 90, 5))
>b : Symbol(b, Decl(enforceReadonly1.ts, 90, 17))

f12({ a: "hello", b: 42 });  // { a: "hello"; b: 42; }
>f12 : Symbol(f12, Decl(enforceReadonly1.ts, 83, 41))
>a : Symbol(a, Decl(enforceReadonly1.ts, 91, 5))
>b : Symbol(b, Decl(enforceReadonly1.ts, 91, 17))

f13({ a: "hello", b: 42 });  // { a: "hello"; readonly b: 42; }
>f13 : Symbol(f13, Decl(enforceReadonly1.ts, 84, 74))
>a : Symbol(a, Decl(enforceReadonly1.ts, 92, 5))
>b : Symbol(b, Decl(enforceReadonly1.ts, 92, 17))

f14({ a: "hello", b: 42 });  // { a: "hello"; b: 42; }
>f14 : Symbol(f14, Decl(enforceReadonly1.ts, 85, 83))
>a : Symbol(a, Decl(enforceReadonly1.ts, 93, 5))
>b : Symbol(b, Decl(enforceReadonly1.ts, 93, 17))

f15({ a: "hello", b: 42 });  // { readonly a: "hello"; readonly b: 42; }
>f15 : Symbol(f15, Decl(enforceReadonly1.ts, 86, 73))
>a : Symbol(a, Decl(enforceReadonly1.ts, 94, 5))
>b : Symbol(b, Decl(enforceReadonly1.ts, 94, 17))

// https://github.com/microsoft/TypeScript/issues/13347

interface MutableValue<T> {
>MutableValue : Symbol(MutableValue, Decl(enforceReadonly1.ts, 94, 27))
>T : Symbol(T, Decl(enforceReadonly1.ts, 98, 23))

    value: T;
>value : Symbol(MutableValue.value, Decl(enforceReadonly1.ts, 98, 27))
>T : Symbol(T, Decl(enforceReadonly1.ts, 98, 23))
}

interface ImmutableValue<T> {
>ImmutableValue : Symbol(ImmutableValue, Decl(enforceReadonly1.ts, 100, 1))
>T : Symbol(T, Decl(enforceReadonly1.ts, 102, 25))

    readonly value: T;
>value : Symbol(ImmutableValue.value, Decl(enforceReadonly1.ts, 102, 29))
>T : Symbol(T, Decl(enforceReadonly1.ts, 102, 25))
}

let i: ImmutableValue<string> = { value: "hi" };
>i : Symbol(i, Decl(enforceReadonly1.ts, 106, 3))
>ImmutableValue : Symbol(ImmutableValue, Decl(enforceReadonly1.ts, 100, 1))
>value : Symbol(value, Decl(enforceReadonly1.ts, 106, 33))

i.value = "Excellent, I can't change it";  // Error
>i.value : Symbol(ImmutableValue.value, Decl(enforceReadonly1.ts, 102, 29))
>i : Symbol(i, Decl(enforceReadonly1.ts, 106, 3))
>value : Symbol(ImmutableValue.value, Decl(enforceReadonly1.ts, 102, 29))

let m: MutableValue<string> = i;  // Error
>m : Symbol(m, Decl(enforceReadonly1.ts, 109, 3))
>MutableValue : Symbol(MutableValue, Decl(enforceReadonly1.ts, 94, 27))
>i : Symbol(i, Decl(enforceReadonly1.ts, 106, 3))

m.value = "Oh dear, I can change it";
>m.value : Symbol(MutableValue.value, Decl(enforceReadonly1.ts, 98, 27))
>m : Symbol(m, Decl(enforceReadonly1.ts, 109, 3))
>value : Symbol(MutableValue.value, Decl(enforceReadonly1.ts, 98, 27))

