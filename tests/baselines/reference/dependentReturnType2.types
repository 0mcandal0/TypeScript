//// [tests/cases/compiler/dependentReturnType2.ts] ////

=== dependentReturnType2.ts ===
// If during narrowing, one of the conditional types in the distribution doesn't narrow, then the whole type will not be narrowed
function whoKnows<T extends string | number | undefined>(x: T): T extends true ? 1 : T extends false ? 2 : 3 {
>whoKnows : <T extends string | number | undefined>(x: T) => T extends true ? 1 : T extends false ? 2 : 3
>x : T
>true : true
>false : false

    if (typeof x !== "string") {
>typeof x !== "string" : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : T
>"string" : "string"

        return 3;
>3 : 3
    }
}

// If the conditional type's input is `never`, then it resolves to `never`:
function neverOk<T extends boolean>(x: T): T extends true ? 1 : T extends false ? 2 : 1 | 2 {
>neverOk : <T extends boolean>(x: T) => T extends true ? 1 : T extends false ? 2 : 1 | 2
>x : T
>true : true
>false : false

    if (x === true) {
>x === true : boolean
>x : T
>true : true

        return 1;
>1 : 1
    }
    if (x === false) {
>x === false : boolean
>x : T
>false : false

        return 2;
>2 : 2
    }
    return 1;
>1 : 1
}
