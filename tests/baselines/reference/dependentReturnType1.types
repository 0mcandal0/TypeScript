//// [tests/cases/compiler/dependentReturnType1.ts] ////

=== dependentReturnType1.ts ===
interface A {
    1: number;
>1 : number

    2: string;
>2 : string
}

function f1<T extends 1 | 2>(x: T): A[T] {
>f1 : <T extends 1 | 2>(x: T) => A[T]
>x : T

    if (x === 1) {
>x === 1 : boolean
>x : T
>1 : 1

        return 0; // Ok
>0 : 0
    }
    else {
        return 1; // Error
>1 : 1
    }
}

interface C {
    1: number;
>1 : number

    2: string;
>2 : string

    3: boolean;
>3 : boolean
}

function f2<T extends 1 | 2 | 3>(x: T): C[T] {
>f2 : <T extends 1 | 2 | 3>(x: T) => C[T]
>x : T

    if (x === 1) {
>x === 1 : boolean
>x : T
>1 : 1

        return 0; // Ok
>0 : 0
    }
    else {
        return ""; // Error, returned expression needs to have type string & boolean (= never)
>"" : ""
    }
}

function f3<T extends 1 | 2 | 3>(x: T): T extends 1 ? number : T extends 2 ? string : T extends 3 ? boolean : never {
>f3 : <T extends 1 | 2 | 3>(x: T) => T extends 1 ? number : T extends 2 ? string : T extends 3 ? boolean : never
>x : T

    if (x === 1) {
>x === 1 : boolean
>x : T
>1 : 1

        return 0; // Ok
>0 : 0
    }
    else {
        return ""; // Error, returned expression needs to have type string & boolean (= never)
>"" : ""
    }
}

interface One {
    a: "a";
>a : "a"

    b: "b";
>b : "b"

    c: "c";
>c : "c"

    d: "d";
>d : "d"
}

interface Two {
    a: "a";
>a : "a"

    b: "b";
>b : "b"

    e: "e";
>e : "e"

    f: "f";
>f : "f"
}

interface Three {
    a: "a";
>a : "a"

    c: "c";
>c : "c"

    e: "e";
>e : "e"

    g: "g";
>g : "g"
}

interface Four {
    a: "a";
>a : "a"

    d: "d";
>d : "d"

    f: "f";
>f : "f"

    g: "g";
>g : "g"
}

function f10<T extends 1 | 2 | 3 | 4>(x: T): T extends 1 ? One : T extends 2 ? Two : T extends 3 ? Three : Four {
>f10 : <T extends 1 | 2 | 3 | 4>(x: T) => T extends 1 ? One : T extends 2 ? Two : T extends 3 ? Three : Four
>x : T

    if (x === 1 || x === 2) {
>x === 1 || x === 2 : boolean
>x === 1 : boolean
>x : T
>1 : 1
>x === 2 : boolean
>x : T
>2 : 2

        return { a: "a", b: "b", c: "c", d: "d", e: "e", f: "f" }; // Ok
>{ a: "a", b: "b", c: "c", d: "d", e: "e", f: "f" } : { a: "a"; b: "b"; c: "c"; d: "d"; e: "e"; f: "f"; }
>a : "a"
>"a" : "a"
>b : "b"
>"b" : "b"
>c : "c"
>"c" : "c"
>d : "d"
>"d" : "d"
>e : "e"
>"e" : "e"
>f : "f"
>"f" : "f"

        return { a: "a" }; // Error
>{ a: "a" } : { a: "a"; }
>a : "a"
>"a" : "a"
    }
    // Excess property becomes a problem with the change,
    // because we now check assignability to a narrower type...
    return { a: "a", b: "b", c: "c", d: "d", e: "e", f: "f", g: "g" }; // Error
>{ a: "a", b: "b", c: "c", d: "d", e: "e", f: "f", g: "g" } : { a: "a"; b: string; c: "c"; d: "d"; e: "e"; f: "f"; g: "g"; }
>a : "a"
>"a" : "a"
>b : string
>"b" : "b"
>c : "c"
>"c" : "c"
>d : "d"
>"d" : "d"
>e : "e"
>"e" : "e"
>f : "f"
>"f" : "f"
>g : "g"
>"g" : "g"
}

// Asymmetry
function conditionalProducingIf<LeftIn, RightIn, LeftOut, RightOut, Arg extends LeftIn | RightIn>(
>conditionalProducingIf : <LeftIn, RightIn, LeftOut, RightOut, Arg extends LeftIn | RightIn>(arg: Arg, cond: (arg: LeftIn | RightIn) => arg is LeftIn, produceLeftOut: (arg: LeftIn) => LeftOut, produceRightOut: (arg: RightIn) => RightOut) => Arg extends LeftIn ? LeftOut : RightOut

    arg: Arg,
>arg : Arg

    cond: (arg: LeftIn | RightIn) => arg is LeftIn,
>cond : (arg: LeftIn | RightIn) => arg is LeftIn
>arg : LeftIn | RightIn

    produceLeftOut: (arg: LeftIn) => LeftOut,
>produceLeftOut : (arg: LeftIn) => LeftOut
>arg : LeftIn

    produceRightOut: (arg: RightIn) => RightOut):
>produceRightOut : (arg: RightIn) => RightOut
>arg : RightIn

    Arg extends LeftIn ? LeftOut : RightOut
{
    type OK = Arg extends LeftIn ? LeftOut : RightOut;
>OK : Arg extends LeftIn ? LeftOut : RightOut

    if (cond(arg)) {
>cond(arg) : boolean
>cond : (arg: LeftIn | RightIn) => arg is LeftIn
>arg : Arg

        return produceLeftOut(arg); // Ok
>produceLeftOut(arg) : LeftOut
>produceLeftOut : (arg: LeftIn) => LeftOut
>arg : Arg & LeftIn

    } else {
        return produceRightOut(arg as RightIn); // Error: Doesn't work because we don't narrow `arg` to `Arg & RightIn` here
>produceRightOut(arg as RightIn) : RightOut
>produceRightOut : (arg: RightIn) => RightOut
>arg as RightIn : RightIn
>arg : Arg
    }
}

interface Animal {
    name: string;
>name : string
}

interface Dog extends Animal {
    bark: () => string;
>bark : () => string
}

// This is unsafe
declare function isDog(x: Animal): x is Dog;
>isDog : (x: Animal) => x is Dog
>x : Animal

declare function doggy(x: Dog): number;
>doggy : (x: Dog) => number
>x : Dog

function f12<T extends Animal>(x: T): T extends Dog ? number : string {
>f12 : <T extends Animal>(x: T) => T extends Dog ? number : string
>x : T

    if (isDog(x)) { // `x` has type `T & Dog` here
>isDog(x) : boolean
>isDog : (x: Animal) => x is Dog
>x : T

        return doggy(x); // Ok
>doggy(x) : number
>doggy : (x: Dog) => number
>x : T & Dog
    }
    return ""; // Error: Should not work because we can't express "not a Dog" in the type system
>"" : ""
}

// Cannot narrow `keyof` too eagerly or something like the below breaks
function f<Entry extends { [index: string]: number | boolean }, EntryId extends keyof Entry>(entry: EntryId): Entry[EntryId] {
>f : <Entry extends { [index: string]: number | boolean; }, EntryId extends keyof Entry>(entry: EntryId) => Entry[EntryId]
>index : string
>entry : EntryId

    const entries = {} as Entry;
>entries : Entry
>{} as Entry : Entry
>{} : {}

    return entries[entry];
>entries[entry] : Entry[EntryId]
>entries : Entry
>entry : EntryId
}

// Works the same as before
declare function takeA(val: 'A'): void;
>takeA : (val: 'A') => void
>val : "A"

export function bounceAndTakeIfA<AB extends 'A' | 'B'>(value: AB): AB {
>bounceAndTakeIfA : <AB extends "A" | "B">(value: AB) => AB
>value : AB

    if (value === 'A') {
>value === 'A' : boolean
>value : AB
>'A' : "A"

        takeA(value);
>takeA(value) : void
>takeA : (val: "A") => void
>value : "A"

        takeAB(value);
>takeAB(value) : void
>takeAB : (val: AB) => void
>value : AB

        return value;
>value : AB
    }

    return value;
>value : AB

    function takeAB(val: AB): void {}
>takeAB : (val: AB) => void
>val : AB
}

// Works the same as before
export function bbb<AB extends "a" | "b">(value: AB): "a" {
>bbb : <AB extends "a" | "b">(value: AB) => "a"
>value : AB

    if (value === "a") {
>value === "a" : boolean
>value : AB
>"a" : "a"

        return value;
>value : "a"
    }
    return "a";
>"a" : "a"
}

class Unnamed {
>Unnamed : Unnamed

    root!: { name: string };
>root : { name: string; }
>name : string

    // Error because parameter is optional
    name<T extends string>(name?: T): T extends string ? this : string {
>name : <T extends string>(name?: T) => T extends string ? this : string
>name : T | undefined

        if (typeof name === 'undefined') {
>typeof name === 'undefined' : boolean
>typeof name : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>name : T | undefined
>'undefined' : "undefined"

            return this.root.name;
>this.root.name : string
>this.root : { name: string; }
>this : this
>root : { name: string; }
>name : string
        }
        return this;
>this : this
    }
    // Error because parameter is optional?
    nameWithError<T extends string>(name?: T): T extends string ? this : string {
>nameWithError : <T extends string>(name?: T) => T extends string ? this : string
>name : T | undefined

        return this; // Error: Investigate error message
>this : this
    }
}

interface Aa {
    1: number;
>1 : number

    2: string;
>2 : string

    3: string;
>3 : string
}

function trivialConditional<T extends 1 | 2 | 3>(x: T): Aa[T] {
>trivialConditional : <T extends 1 | 2 | 3>(x: T) => Aa[T]
>x : T

    if (x !== 1) {
>x !== 1 : boolean
>x : T
>1 : 1

        return x === 2 ? "" : `${x}`;
>x === 2 ? "" : `${x}` : string
>x === 2 : boolean
>x : T
>2 : 2
>"" : ""
>`${x}` : string
>x : T
    }
    else {
        return 0;
>0 : 0
    }
}

// Conditional expressions
function conditional<T extends boolean>(x: T): T extends true ? 1 : 2 {
>conditional : <T extends boolean>(x: T) => T extends true ? 1 : 2
>x : T
>true : true

    return x ? 1 : 2; // Ok
>x ? 1 : 2 : 1 | 2
>x : T
>1 : 1
>2 : 2
}

function contextualConditional<T extends "a" | "b">(x: T): T extends "a" ? "a" : number {
>contextualConditional : <T extends "a" | "b">(x: T) => T extends "a" ? "a" : number
>x : T

    return x === "a" ? x : parseInt(x); // Ok
>x === "a" ? x : parseInt(x) : number | "a"
>x === "a" : boolean
>x : T
>"a" : "a"
>x : "a"
>parseInt(x) : number
>parseInt : (string: string, radix?: number | undefined) => number
>x : "b"
}

function conditionalWithError<T extends "a" | "b">(x: T): T extends "a" ? number : string {
>conditionalWithError : <T extends "a" | "b">(x: T) => T extends "a" ? number : string
>x : T

    return x === "a" ? x : parseInt(x); // Error
>x === "a" ? x : parseInt(x) : number | "a"
>x === "a" : boolean
>x : T
>"a" : "a"
>x : "a"
>parseInt(x) : number
>parseInt : (string: string, radix?: number | undefined) => number
>x : "b"
}

// Multiple reductions
interface BB {
    "a": number;
>"a" : number

    [y: number]: string;
>y : number
}

interface AA<T extends keyof BB> {
    "c": BB[T];
>"c" : BB[T]

    "d": boolean,
>"d" : boolean
}

function reduction<T extends keyof BB, U extends "c" | "d">(x: T, y: U): AA<T>[U] {
>reduction : <T extends keyof BB, U extends "c" | "d">(x: T, y: U) => AA<T>[U]
>x : T
>y : U

    if (y === "c" && x === "a") {
>y === "c" && x === "a" : boolean
>y === "c" : boolean
>y : U
>"c" : "c"
>x === "a" : boolean
>x : T
>"a" : "a"

        // AA<T>[U='c'] -> BB[T]
        // BB[T='a'] -> number
        return 0; // Ok
>0 : 0
    }

    return undefined as never;
>undefined as never : never
>undefined : undefined
}

// Substitution types are not narrowed?
function subsCond<T extends 1 | 2 | 3>(x: T): T extends 1 | 2 ? (T extends 1 ? string : boolean) : number {
>subsCond : <T extends 1 | 2 | 3>(x: T) => T extends 1 | 2 ? (T extends 1 ? string : boolean) : number
>x : T

    if (x === 1) {
>x === 1 : boolean
>x : T
>1 : 1

        return "";
>"" : ""
    }
}

// Unsafe: supertype problem
declare function q(x: object): x is { b: number };
>q : (x: object) => x is { b: number; }
>x : object
>b : number

function foo<T extends { a: string } | { b: number }>(x: T): T extends { a: string } ? number : (string | number) {
>foo : <T extends { a: string; } | { b: number; }>(x: T) => T extends {    a: string;} ? number : (string | number)
>a : string
>b : number
>x : T
>a : string

    if (q(x)) {
>q(x) : boolean
>q : (x: object) => x is { b: number; }
>x : { a: string; } | { b: number; }

        x.b;
>x.b : number
>x : { b: number; }
>b : number

        return "";
>"" : ""
    }
}

let y = { a: "", b: 1 }
>y : { a: string; b: number; }
>{ a: "", b: 1 } : { a: string; b: number; }
>a : string
>"" : ""
>b : number
>1 : 1

const r = foo<{ a: string }>(y); // number
>r : number
>foo<{ a: string }>(y) : number
>foo : <T extends { a: string; } | { b: number; }>(x: T) => T extends { a: string; } ? number : string | number
>a : string
>y : { a: string; b: number; }

type HelperCond<T, A, R1, B, R2> = T extends A ? R1 : T extends B ? R2 : R1 | R2;
>HelperCond : HelperCond<T, A, R1, B, R2>

function foo2<U extends string | number, V extends boolean>(x: U, y: V):
>foo2 : <U extends string | number, V extends boolean>(x: U, y: V) => HelperCond<{ x: U; y: V; }, { x: string; y: true; }, 1, { x: number; y: false; }, 2>
>x : U
>y : V

    HelperCond<{ x: U, y: V },
>x : U
>y : V

        { x: string, y: true }, 1,
>x : string
>y : true
>true : true

        { x: number, y: false }, 2> {
>x : number
>y : false
>false : false

    if (typeof x === "string" && y === true) {
>typeof x === "string" && y === true : boolean
>typeof x === "string" : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : U
>"string" : "string"
>y === true : boolean
>y : V
>true : true

        return 1;
>1 : 1
    }
    if (typeof x === "number" && y === false) {
>typeof x === "number" && y === false : boolean
>typeof x === "number" : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : U
>"number" : "number"
>y === false : boolean
>y : V
>false : false

        return 2;
>2 : 2
    }
    return 0;
>0 : 0
}

// >> TODO: test non-tail recursive and tail recursive conditionals

// >> TODO: fix this
function voidRet<T extends { a: string } | undefined>(x: T): T extends {} ? void : number {
>voidRet : <T extends { a: string; } | undefined>(x: T) => T extends {} ? void : number
>a : string
>x : T

    if (x) {
>x : T

        return;
    }
    return 1;
>1 : 1
}
