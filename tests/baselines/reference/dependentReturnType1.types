=== tests/cases/compiler/dependentReturnType1.ts ===
interface A {
    1: number;
>1 : number

    2: string;
>2 : string
}

function f1<T extends 1 | 2>(x: T): A[T] {
>f1 : <T extends 1 | 2>(x: T) => A[T]
>x : T

    if (x === 1) {
>x === 1 : boolean
>x : T
>1 : 1

        return 0;
>0 : 0
    }
    else {
        return 1;
>1 : 1
    }
}

interface C {
    1: number;
>1 : number

    2: string;
>2 : string

    3: boolean;
>3 : boolean
}

function f2<T extends 1 | 2 | 3>(x: T): C[T] {
>f2 : <T extends 1 | 2 | 3>(x: T) => C[T]
>x : T

    if (x === 1) {
>x === 1 : boolean
>x : T
>1 : 1

        return 0;
>0 : 0
    }
    else {
        return ""; // Error, returned expression needs to have type string & boolean (= never)
>"" : ""
    }
}

function f3<T extends 1 | 2 | 3>(x: T): T extends 1 ? number : T extends 2 ? string : T extends 3 ? boolean : never {
>f3 : <T extends 1 | 2 | 3>(x: T) => T extends 1 ? number : T extends 2 ? string : T extends 3 ? boolean : never
>x : T

    if (x === 1) {
>x === 1 : boolean
>x : T
>1 : 1

        return 0;
>0 : 0
    }
    else {
        return ""; // Error, returned expression needs to have type string & boolean (= never)
>"" : ""
    }
}

interface One {
    a: "a";
>a : "a"

    b: "b";
>b : "b"

    c: "c";
>c : "c"

    d: "d";
>d : "d"
}

interface Two {
    a: "a";
>a : "a"

    b: "b";
>b : "b"

    e: "e";
>e : "e"

    f: "f";
>f : "f"
}

interface Three {
    a: "a";
>a : "a"

    c: "c";
>c : "c"

    e: "e";
>e : "e"

    g: "g";
>g : "g"
}

interface Four {
    a: "a";
>a : "a"

    d: "d";
>d : "d"

    f: "f";
>f : "f"

    g: "g";
>g : "g"
}

function f10<T extends 1 | 2 | 3 | 4>(x: T): T extends 1 ? One : T extends 2 ? Two : T extends 3 ? Three : Four {
>f10 : <T extends 1 | 2 | 3 | 4>(x: T) => T extends 1 ? One : T extends 2 ? Two : T extends 3 ? Three : Four
>x : T

    if (x === 1 || x === 2) {
>x === 1 || x === 2 : boolean
>x === 1 : boolean
>x : T
>1 : 1
>x === 2 : boolean
>x : T
>2 : 2

        // return { a: "a", b: "b", c: "c", d: "d", e: "e", f: "f" };
        return { a: "a" };
>{ a: "a" } : { a: "a"; }
>a : "a"
>"a" : "a"
    }
    // Excess property becomes a problem with the change,
    // because we now check assignability to a narrower type...
    return { a: "a", b: "b", c: "c", d: "d", e: "e", f: "f", g: "g" };
>{ a: "a", b: "b", c: "c", d: "d", e: "e", f: "f", g: "g" } : { a: "a"; b: string; c: "c"; d: "d"; e: "e"; f: "f"; g: "g"; }
>a : "a"
>"a" : "a"
>b : string
>"b" : "b"
>c : "c"
>"c" : "c"
>d : "d"
>"d" : "d"
>e : "e"
>"e" : "e"
>f : "f"
>"f" : "f"
>g : "g"
>"g" : "g"
}

// Asymmetry
function conditionalProducingIf<LeftIn, RightIn, LeftOut, RightOut, Arg extends LeftIn | RightIn>(
>conditionalProducingIf : <LeftIn, RightIn, LeftOut, RightOut, Arg extends LeftIn | RightIn>(arg: Arg, cond: (arg: LeftIn | RightIn) => arg is LeftIn, produceLeftOut: (arg: LeftIn) => LeftOut, produceRightOut: (arg: RightIn) => RightOut) => Arg extends LeftIn ? LeftOut : RightOut

    arg: Arg,
>arg : Arg

    cond: (arg: LeftIn | RightIn) => arg is LeftIn,
>cond : (arg: LeftIn | RightIn) => arg is LeftIn
>arg : LeftIn | RightIn

    produceLeftOut: (arg: LeftIn) => LeftOut,
>produceLeftOut : (arg: LeftIn) => LeftOut
>arg : LeftIn

    produceRightOut: (arg: RightIn) => RightOut):
>produceRightOut : (arg: RightIn) => RightOut
>arg : RightIn

    Arg extends LeftIn ? LeftOut : RightOut
{
    type OK = Arg extends LeftIn ? LeftOut : RightOut;
>OK : Arg extends LeftIn ? LeftOut : RightOut

    if (cond(arg)) {
>cond(arg) : boolean
>cond : (arg: LeftIn | RightIn) => arg is LeftIn
>arg : Arg

        return produceLeftOut(arg);
>produceLeftOut(arg) : LeftOut
>produceLeftOut : (arg: LeftIn) => LeftOut
>arg : Arg & LeftIn

    } else {
        return produceRightOut(arg as RightIn); // Doesn't work because we don't narrow `arg` to `Arg & RightIn` here
>produceRightOut(arg as RightIn) : RightOut
>produceRightOut : (arg: RightIn) => RightOut
>arg as RightIn : RightIn
>arg : Arg

        return produceRightOut(arg as RightIn) as OK;
>produceRightOut(arg as RightIn) as OK : Arg extends LeftIn ? LeftOut : RightOut
>produceRightOut(arg as RightIn) : RightOut
>produceRightOut : (arg: RightIn) => RightOut
>arg as RightIn : RightIn
>arg : Arg
    }
}

interface Animal {
    name: string;
>name : string
}

interface Dog extends Animal {
    bark: () => string;
>bark : () => string
}

declare function isDog(x: Animal): x is Dog;
>isDog : (x: Animal) => x is Dog
>x : Animal

declare function doggy(x: Dog): number;
>doggy : (x: Dog) => number
>x : Dog

function f12<T extends Animal>(x: T): T extends Dog ? number : string {
>f12 : <T extends Animal>(x: T) => T extends Dog ? number : string
>x : T

    if (isDog(x)) { // `x` has type `T & Dog` here
>isDog(x) : boolean
>isDog : (x: Animal) => x is Dog
>x : T

        return doggy(x); // Should work
>doggy(x) : number
>doggy : (x: Dog) => number
>x : T & Dog
    }
    return ""; // Should not work because we can't express "not a Dog" in the type system
>"" : ""
}

// Cannot narrow `keyof` too eagerly or something like the below breaks
function f<Entry extends { [index: string]: number | boolean }, EntryId extends keyof Entry>(entry: EntryId): Entry[EntryId] {
>f : <Entry extends { [index: string]: number | boolean; }, EntryId extends keyof Entry>(entry: EntryId) => Entry[EntryId]
>index : string
>entry : EntryId

    const entries = {} as Entry;
>entries : Entry
>{} as Entry : Entry
>{} : {}

    return entries[entry];
>entries[entry] : Entry[EntryId]
>entries : Entry
>entry : EntryId
}

// Works the same as before
declare function takeA(val: 'A'): void;
>takeA : (val: 'A') => void
>val : "A"

export function bounceAndTakeIfA<AB extends 'A' | 'B'>(value: AB): AB {
>bounceAndTakeIfA : <AB extends "A" | "B">(value: AB) => AB
>value : AB

    if (value === 'A') {
>value === 'A' : boolean
>value : AB
>'A' : "A"

        takeA(value);
>takeA(value) : void
>takeA : (val: "A") => void
>value : "A"

        takeAB(value);
>takeAB(value) : void
>takeAB : (val: AB) => void
>value : AB

        return value;
>value : AB
    }

    return value;
>value : AB

    function takeAB(val: AB): void {}
>takeAB : (val: AB) => void
>val : AB
}

// Works the same as before
export function bbb<AB extends "a" | "b">(value: AB): "a" {
>bbb : <AB extends "a" | "b">(value: AB) => "a"
>value : AB

    if (value === "a") {
>value === "a" : boolean
>value : AB
>"a" : "a"

        return value;
>value : "a"
    }
    return "a";
>"a" : "a"
}

class Unnamed {
>Unnamed : Unnamed

    root!: { name: string };
>root : { name: string; }
>name : string

    name<T extends string>(name?: T): T extends string ? this : string {
>name : <T extends string>(name?: T) => T extends string ? this : string
>name : T | undefined

        if (typeof name === 'undefined') {
>typeof name === 'undefined' : boolean
>typeof name : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>name : T | undefined
>'undefined' : "undefined"

            return this.root.name;
>this.root.name : string
>this.root : { name: string; }
>this : this
>root : { name: string; }
>name : string
        }
        return this;
>this : this
    }

    nameWithError<T extends string>(name?: T): T extends string ? this : string {
>nameWithError : <T extends string>(name?: T) => T extends string ? this : string
>name : T | undefined

        return this; // Investigate error message
>this : this
    }
}

interface A {
    1: number;
>1 : number

    2: string;
>2 : string

    3: string;
>3 : string
}

function trivialConditional<T extends 1 | 2 | 3>(x: T): A[T] {
>trivialConditional : <T extends 1 | 2 | 3>(x: T) => A[T]
>x : T

    if (x !== 1) {
>x !== 1 : boolean
>x : T
>1 : 1

        return x === 2 ? "" : `${x}`;
>x === 2 ? "" : `${x}` : string
>x === 2 : boolean
>x : T
>2 : 2
>"" : ""
>`${x}` : string
>x : T
    }
    else {
        return 0;
>0 : 0
    }
}

// Conditional expressions
function conditional<T extends boolean>(x: T): T extends true ? 1 : 2 {
>conditional : <T extends boolean>(x: T) => T extends true ? 1 : 2
>x : T
>true : true

    return x ? 1 : 2;
>x ? 1 : 2 : 1 | 2
>x : T
>1 : 1
>2 : 2
}

function contextualConditional<T extends "a" | "b">(x: T): T extends "a" ? "a" : number {
>contextualConditional : <T extends "a" | "b">(x: T) => T extends "a" ? "a" : number
>x : T

    return x === "a" ? x : parseInt(x);
>x === "a" ? x : parseInt(x) : number | "a"
>x === "a" : boolean
>x : T
>"a" : "a"
>x : "a"
>parseInt(x) : number
>parseInt : (string: string, radix?: number | undefined) => number
>x : "b"
}

function conditionalWithError<T extends "a" | "b">(x: T): T extends "a" ? number : string {
>conditionalWithError : <T extends "a" | "b">(x: T) => T extends "a" ? number : string
>x : T

    return x === "a" ? x : parseInt(x);
>x === "a" ? x : parseInt(x) : number | "a"
>x === "a" : boolean
>x : T
>"a" : "a"
>x : "a"
>parseInt(x) : number
>parseInt : (string: string, radix?: number | undefined) => number
>x : "b"
}

// Multiple reductions
interface BB {
    "a": number;
>"a" : number

    [y: number]: string;
>y : number
}

interface AA<T extends keyof BB> {
    "c": BB[T];
>"c" : BB[T]

    "d": boolean,
>"d" : boolean
}

function reduction<T extends keyof BB, U extends "c" | "d">(x: T, y: U): AA<T>[U] {
>reduction : <T extends keyof BB, U extends "c" | "d">(x: T, y: U) => AA<T>[U]
>x : T
>y : U

    if (y === "c" && x === "a") {
>y === "c" && x === "a" : boolean
>y === "c" : boolean
>y : U
>"c" : "c"
>x === "a" : boolean
>x : T
>"a" : "a"

        // AA<T>[U='c'] -> BB[T]
        // BB[T='a'] -> number
        return 0;
>0 : 0
    }

    return undefined as never;
>undefined as never : never
>undefined : undefined
}

// Conditional with substitution types should also be narrowed
function subsCond<T extends 1 | 2 | 3>(x: T): T extends 1 | 2 ? (T extends 1 ? string : boolean) : number {
>subsCond : <T extends 1 | 2 | 3>(x: T) => T extends 1 | 2 ? (T extends 1 ? string : boolean) : number
>x : T

    if (x === 1) {
>x === 1 : boolean
>x : T
>1 : 1

        return "";
>"" : ""
    }
}

// TODO: test non-tail recursive and tail recursive conditionals
